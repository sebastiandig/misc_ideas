---
title: "Spatial Data Tests"
author: "Sebastian Di Geronimo"
date: 2025-03-07
format: html
editor: source
---

# 1.0 ---- Summary of Document ----



# 2.0 ---- Setup ----


## 2.1 Load Libraries

```{r setup, include=FALSE}
if (!nzchar(system.file(package = "librarian"))) 
  install.packages("librarian")

librarian::shelf(
  quiet = TRUE,
  librarian, conflicted, ggplot2, tibble, tidyr, readr, purrr, dplyr, stringr,
  forcats, lubridate, glue, fs, magrittr, here,
  
  # additional
  ggspatial
)

conflicts_prefer(
  dplyr::filter(), 
  dplyr::select()
  )
  

```


# 3.0 From: `ggspatial` Startup

```{r}
load_longlake_data()

ggplot() +
  # loads background map tiles from a tile source
  annotation_map_tile(zoomin = -1) +
  
  # annotation_spatial() layers don't train the scales, so data stays central
  annotation_spatial(longlake_roadsdf, size = 2, col = "black") +
  annotation_spatial(longlake_roadsdf, size = 1.6, col = "white") +

  # raster layers train scales and get projected automatically
  layer_spatial(
    longlake_depth_raster,
    # aes(colour = after_stat(band1))
    ) +
  # make no data values transparent
  scale_fill_viridis_c(na.value = NA) +
  
  # layer_spatial trains the scales
  layer_spatial(longlake_depthdf, aes(fill = DEPTH_M)) +
  
  # spatial-aware automagic scale bar
  annotation_scale(location = "tl") +

  # spatial-aware automagic north arrow
  annotation_north_arrow(location = "br", which_north = "true")
```


# SMAP-SSS Data


```{r}
shelf(terra)

test <- 
here("data", "raw") %>%
  dir_ls(regexp = "SSS") %>%
  terra::rast()

test
names(test)
plot(test[2])
```


# AVISO+ Sea Surface Height and Velocity

Data downloaded from `Copernicus` for both absolute dynamic topography (m) and
north/east surface velocities (m/s)

Data:       Global Ocean Gridded L4 Sea Surface Heights And Derived Variables
Search:     <https://data.marine.copernicus.eu/products>
Product ID: `SEALEVEL_GLO_PHY_L4_MY_008_047`
Dataset ID: `cmems_obs-sl_glo_phy-ssh_my_allsat-l4-duacs-0.125deg_P1D`
Description: <https://data.marine.copernicus.eu/product/SEALEVEL_GLO_PHY_L4_MY_008_047/description>
Bounds:     
  Lon: -83.8125, -78.3125  
  Lat:  22.8125,  26.4375
Note: Select all data products when downloading from `MyOceanPro`
      If downloading from `description` page, go to `Data access` then `subset`, 
      then `automate`. Copy the `automate` and modify script below to download
      multiple dates.

Data Info:
<https://documentation.marine.copernicus.eu/PUM/CMEMS-SL-PUM-008-032-068.pdf>


Velocites extraction inspired from:
<https://help.marine.copernicus.eu/en/articles/9711615-how-to-plot-current-vectors-using-r>

## Load Packages
```{r aviso-libs}
shelf(sf, ncdf4, stars, terra)
```
## Download Data from `Copernicusmarine` using `copernicusmarine.exe` File

From: <https://help.marine.copernicus.eu/en/articles/10750437-copernicus-marine-toolbox-executable-no-installation>

I recommend moving the file to this directory where this project is stored

To start, open `cmd` or `PowerShell` from explorer. `cd` to location where `.exe`
is located. Then run `copernicusmarine login` and enter "Username" and
"Password". Once completed, you should be able to run the download


```{r download-aviso}
# set to TRUE if downloading data
download <- FALSE
# download <- TRUE

# path to executeable and path to save data
path_copernicusmarine <- here("copernicusmarine.exe")
path_save <- here("data", "raw", "copernicus")

dir_create(path_save)

# set date range
date_range <-
  c(
    start = "2019-09-06",
    end   = "2019-09-06"
  ) %>%
  as_datetime() %>%
  lubridate::format_ISO8601()

# set spatial extent
ssh_bbox <-
  c(
    xmin = -83.8125,
    xmax = -78.3125,
    ymin = 22.8125,
    ymax = 26.4375
  )

# select vars
vars <-
  c(
    "adt",
    "err_sla",
    "err_ugosa",
    "err_vgosa",
    "flag_ice",
    "sla",
    "tpa_correction",
    "ugos",
    "ugosa",
    "vgos",
    "vgosa"
  )

# set up command to download
command <-
  paste(
    shQuote(path_copernicusmarine),
    "subset",
    "--dataset-id cmems_obs-sl_glo_phy-ssh_my_allsat-l4-duacs-0.125deg_P1D",
    paste("--variable", vars, collapse = " "),
    "--start-datetime",    date_range[1],
    "--end-datetime",      date_range[2],
    "--minimum-longitude", ssh_bbox["xmin"],
    "--maximum-longitude", ssh_bbox["xmax"],
    "--minimum-latitude",  ssh_bbox["ymin"],
    "--maximum-latitude",  ssh_bbox["ymax"],
    "-o", path_save
  )

if (download) {
  message("Downloading AVISO+ Date")

  # execute command to download files
  system(command)
} else {
  message("Not downloading AVISO+ data")
}

```

## Load One Image Data


```{r aviso-data}
# path to data
ssh_path <- 
  here::here("data", "raw") %>%
  dir_ls(regexp = "cmems_obs-sl_glo_phy-ssh_my_allsat-l4-duacs") 

# open data and extract variables
ssh_nc   <- nc_open(ssh_path)

attributes(ssh_nc$var) # show vars names
attributes(ssh_nc$dim) # show vars names

adt  <- ncvar_get(ssh_nc, "adt")
vgos <- ncvar_get(ssh_nc, "vgos")
ugos <- ncvar_get(ssh_nc, "ugos")
lat  <- ncvar_get(ssh_nc, "latitude")
lon  <- ncvar_get(ssh_nc, "longitude")

nc_close(ssh_nc)

# create grid data
ssh_grid <- 
  expand.grid(lon = lon, lat = lat) %>%
  mutate(
    adt     = as.vector(adt),       # absolute dynamic topography
    vgos    = as.vector(vgos),      # north geostrophic velocity
    ugos    = as.vector(ugos),      # east geostrophic velocity
    vel_mag = sqrt(vgos^2 + ugos^2) # calculate current velocity
  ) %T>%
  print()

# load coastline
coast <-
  rnaturalearth::ne_coastline(10, returnclass = "sf") %>%
  st_crop(
    xmin = min(ssh_grid$lon),
    ymin = min(ssh_grid$lat),
    xmax = max(ssh_grid$lon),
    ymax = max(ssh_grid$lat)
  )
```

## Plot Data

```{r aviso-plot}
# number of rows to skip in ssh_grid for vectors and length of magnitude division
slice_by      <- 10
length_divide <- 2

# plot absolute dynamic topography and velocities
plt <- ggplot() +
  geom_tile(data = ssh_grid, aes(x = lon, y = lat, fill = adt)) +
  geom_sf(data = coast) +
  scale_fill_viridis_b() +
  coord_sf(expand = FALSE, 
           ylim = c(min(ssh_grid$lat), max(ssh_grid$lat)),
           xlim = c(min(ssh_grid$lon), max(ssh_grid$lon))
           ) +
  labs(
    fill  = "ADT",
    color = expression(Vel~(m~s^-1)),
    x     = NULL,
    y     = NULL
  ) +
  geom_segment(
    data = slice(ssh_grid, seq(1, n(), by = slice_by)),
    aes(
      x     = lon, 
      xend  = lon + ugos/length_divide, 
      y     = lat, 
      yend  = lat + vgos/length_divide, 
      color = vel_mag
      ),
    arrow     = arrow(length = unit(0.15, "cm")), # adjust arrow size
    linewidth = 0.5,                              # adjust arrow thickness
    na.rm     = TRUE
  ) +
  scale_color_viridis_b(option = "magma", breaks = c(0.25, seq(0, 2, by = 0.5))) +
  theme_bw() 



if (any(str_detect(colnames(ssh_grid), "date"))) {
  plt <- 
    plt +
    facet_wrap(~date, ncol = 2)
}

plt
```





```{r}
rssh_grid_rast <- 
  ssh_grid %>%
  terra::rast(crs = "EPSG:4326") 

transect_file <- here(path_save, "transects.shp")

if (file_exists(transect_file)) {
  message("Reading transects shapefile")
  linestring <- st_read(transect_file)
} else {
  message("Creating transects.")
  polyline <-
    (mapview::mapView(rssh_grid_rast, layer = "adt") +
      mapview::mapview(coast)
    ) %>%
    mapedit::editMap()

  linestring <- polyline$finished

  names(linestring) <- c("id", "type", "geometry")

  message(paste0("Saving transects as `", basename(transect_file), "`."))
  
  st_write(
    linestring,
    transect_file
  )
}


```


```{r}
rssh_grid_rast 

# velocity with transects
plt +
  geom_sf(data = linestring, color = "red")

# extract pixels along transect
vel_extract <- terra::extract(rssh_grid_rast, linestring, xy = TRUE)

# plot pixels detected along transect
plt +
  geom_sf(data = linestring, color = "red") +
  geom_point(data = vel_extract, aes(x = x,  y = y), color = "blue") +
  geom_point(data = filter(vel_extract, vel_mag >= 0.5), aes(x = x,  y = y), color = "green")

# plot speed of transects as distance from shore
vel_extract %>%
  mutate(
    .by = ID,
    lagx = first(x), 
    lagy = first(y)
    ) %>%
  rowwise() %>%
  mutate(dist = geodist::geodist_vec(lagx, lagy, x, y, measure = "geodesic") / 1000) %>%
  ggplot(aes(x = dist, y = vel_mag, color = as.factor(ID))) +
  geom_hline(yintercept = 0.5, color = "red") +
  geom_path() +
  geom_point() +
  labs(color = "ID", x = NULL, y = expression("Velocity"~(m~s^-1))) +
  coord_cartesian(expand = FALSE)

# extract starting point of each transect
polyline_pts <- 
  linestring %>% 
  st_coordinates() %>%
  as_tibble(.name_repair = janitor::make_clean_names) %>%
  slice_head(by = l1) %T>% 
  print()

plt +
  geom_sf(data = linestring, color = "red", alpha = 0.5, linetype = "dashed") +
  geom_point(data = polyline_pts, aes(x = x, y = y), color = "red") +
  geom_point(
    data = filter(vel_extract, vel_mag >= 0.5) %>%
           slice_head(by = ID), 
    aes(x = x,  y = y), color = "green")


left_join(
  polyline_pts,
  filter(vel_extract, vel_mag >= 0.5) %>%
    slice_head(by = ID),
  by = c("l1" = "ID"),
  suffix = c("_shr", "_fc")
  ) %>%
  rowwise() %>%
  mutate(
    dist = geodist::geodist_vec(
      x_shr, y_shr, 
      x_fc, y_fc, 
      measure = "geodesic") / 1000
    ) %>%
  ungroup()

```


# Multiday Plots

## Load Muliple Dates

If there are multiple time dimensions, will load each date into its own list

```{r load-multi}
ssh_path <-
  here::here("data", "raw") %>%
  rstudioapi::selectFile(path = .)

ssh_path <-
  here::here("data", "raw") %>%
  rstudioapi::selectDirectory(path = .) %>%
  dir_ls(regexp = "mems_obs-sl_glo") %>%
  .[1:12]
```


```{r load-multi}
multi_day <- vector("list", length(ssh_path))

for (j in seq(ssh_path)) {
  # open data and extract variables
  ssh_nc <- nc_open(ssh_path[j])

  attributes(ssh_nc$var) # show vars names
  attributes(ssh_nc$dim) # show vars names

  # determine number of time dimensions
  nc_len   <- ssh_nc$dim$time$len
  dat_grid <- vector("list", nc_len)

  # extract dates
  nc_date <- as_date(ncvar_get(ssh_nc, "time"), origin = as_date(ssh_nc$dim$time$units))

  for (i in seq(nc_len)) {
    # extract variables
    adt  <- ncvar_get(ssh_nc, "adt")[, , i]
    vgos <- ncvar_get(ssh_nc, "vgos")[, , i]
    ugos <- ncvar_get(ssh_nc, "ugos")[, , i]
    lat  <- ncvar_get(ssh_nc, "latitude")
    lon  <- ncvar_get(ssh_nc, "longitude")

    # create grid data
    ssh_grid <-
      expand.grid(lon = lon, lat = lat) %>%
      mutate(
        adt     = as.vector(adt), # absolute dynamic topography
        vgos    = as.vector(vgos), # north geostrophic velocity
        ugos    = as.vector(ugos), # east geostrophic velocity
        vel_mag = sqrt(vgos^2 + ugos^2) # calculate current velocity
      )

    dat_grid[[i]] <- ssh_grid
  }

  # set list names to date
  names(dat_grid) <- nc_date

  # close `.nc` file
  nc_close(ssh_nc)

  dat_grid

  multi_day[[j]] <- dat_grid
}

# convert to tibble
ssh_grid_tibble <-
  # ssh_grid <-
  dat_grid %>%
  list_rbind(names_to = "date")

dat_grid <-
  multi_day %>%
  list_flatten()

ssh_grid_tibble <-
  dat_grid %>%
  list_rbind(names_to = "date")

```


## Create Multi-day Raster

```{r}
multi_rast <- 
  unname(dat_grid) %>%
  lapply(.,\(.x) rast(.x, crs = "EPSG:4326")) %>%
  rast()
multi_rast

# load coastline
coast <-
  rnaturalearth::ne_coastline(10, returnclass = "sf") %>%
  st_crop(
    xmin = terra::ext(multi_rast)[1][[1]],
    ymin = terra::ext(multi_rast)[3][[1]],
    xmax = terra::ext(multi_rast)[2][[1]],
    ymax = terra::ext(multi_rast)[4][[1]]
  )

ylim <- c(terra::ext(multi_rast)[3], terra::ext(multi_rast)[4])
xlim <- c(terra::ext(multi_rast)[1], terra::ext(multi_rast)[2])
```
# Create Transects

```{r}
transect_file <- here(path_save, "transects.shp")

if (file_exists(transect_file)) {
  message("Reading transects shapefile")
  linestring <- st_read(transect_file)
} else {
  message("Creating transects.")
  lyr_name <- grep("vel_mag", names(multi_rast), value = TRUE)[1]
  
  polyline <-
    (mapview::mapView(multi_rast, layer = lyr_name) +
      mapview::mapview(coast)
    ) %>%
    mapedit::editMap()

  linestring <- polyline$finished

  names(linestring) <- c("id", "type", "geometry")

  message(paste0("Saving transects as `", basename(transect_file), "`."))
  
  st_write(
    linestring,
    transect_file
  )
}
```

## Extract Pixels along Transects
```{r}
n_layers <- nlyr(multi_rast) / length(dat_grid)

rast_names <- 
  names(dat_grid) %>% 
  rep(each = n_layers) %>% 
  as_date()

time(multi_rast)  <- rast_names
names(multi_rast) <- paste(names(multi_rast), rast_names, sep = "_")
names(multi_rast)

vel_ext_transect <- 
 terra::extract(multi_rast, linestring, xy = TRUE) %>%
 select(ID, x , y, contains("vel_mag")) %>%
  pivot_longer(
    cols      = c(-ID, -x, -y),     # columns to pivot long,
    names_to  = "name",  # desired name for category column
    values_to = "vel_mag", # desired name for value column
    ) %>%
  mutate(
    date = str_extract(name, "\\d.*"),
    # date = as_date(date)
  ) %T>% 
  print()
```


```{r}
shelf(gganimate, transformr)
```


```{r}
plt_mag_vel <- 
  ggplot() +
  geom_tile(data = ssh_grid_tibble, aes(x = lon, y = lat, fill = vel_mag)) +
  geom_sf(data = coast) +
  scale_fill_viridis_b() +
  geom_sf(data = linestring, color = "red") +
  geom_point(data = vel_ext_transect, aes(x = x,  y = y), color = "blue") +
  geom_point(data = filter(vel_ext_transect, vel_mag >= 0.5), aes(x = x,  y = y), color = "green") +
  gganimate::transition_states(date) +
  labs(title = "Date: {closest_state}")
  # facet_wrap(~date)
anim_save("mag_vel.gif", plt_mag_vel, path = here())
```


```{r}
slice_by      <- 5
length_divide <- 2
plt_mag_vel_vect <- 
  ggplot() +
  geom_tile(data = ssh_grid_tibble, aes(x = lon, y = lat, fill = vel_mag)) +
  geom_sf(data = coast) +
  scale_fill_viridis_b() +
  geom_sf(data = linestring, color = "red")  +
  geom_point(data = vel_ext_transect, aes(x = x,  y = y), color = "blue") +
  geom_point(data = filter(vel_ext_transect, vel_mag >= 0.5), aes(x = x,  y = y), 
             color = "green") +
  geom_segment(
    data = slice(ssh_grid_tibble, seq(1, n(), by = slice_by)),
    aes(
      x     = lon, 
      xend  = lon + ugos/length_divide, 
      y     = lat, 
      yend  = lat + vgos/length_divide, 
      color = vel_mag
      ),
    arrow     = arrow(length = unit(0.15, "cm")), # adjust arrow size
    linewidth = 0.5,                              # adjust arrow thickness
    na.rm     = TRUE
  ) +
  scale_color_viridis_b(option = "magma", breaks = c(0.25, seq(0, 2, by = 0.5))) +
  theme_bw() +
  labs(x = NULL, y = NULL) +
  coord_sf(expand = FALSE, ylim = ylim, xlim = xlim) +
  # facet_wrap(~date)
  gganimate::transition_states(date) +
  labs(title = "Date: {closest_state}")

# plt_mag_vel_vect
anim_save("mag_vel_vect.gif", plt_mag_vel_vect, path = here())

```


```{r}
vel_ext_transect %>%
  mutate(
    .by = ID,
    lagx = first(x), 
    lagy = first(y)
    ) %>%
  rowwise() %>%
  mutate(dist = geodist::geodist_vec(lagx, lagy, x, y, measure = "geodesic") / 1000) %>%
  ggplot(aes(x = dist, y = vel_mag, color = as.factor(ID))) +
  geom_hline(yintercept = 0.5, color = "red") +
  geom_path() +
  geom_point() +
  labs(color = "ID", x = NULL, y = expression("Velocity"~(m~s^-1))) +
  coord_cartesian(expand = FALSE) +
  # facet_wrap(~date)
  gganimate::transition_states(date, state_length = 0.25) +
  labs(title = "Date: {closest_state}")
```


## Extract Distance from Shore

```{r}
# extract starting point of each transect
polyline_pts <- 
  linestring %>% 
  st_coordinates() %>%
  as_tibble(.name_repair = janitor::make_clean_names) %>%
  slice_head(by = l1) %T>% 
  print()

left_join(
  polyline_pts,
  filter(vel_ext_transect, vel_mag >= 0.5) %>%
    slice_head(by = c(ID, date)),
  by = c("l1" = "ID"),
  suffix = c("_shr", "_fc")
  ) %>%
  rowwise() %>%
  mutate(
    dist = geodist::geodist_vec(
      x_shr, y_shr, 
      x_fc, y_fc, 
      measure = "geodesic") / 1000
    ) %>%
  ungroup()
```
