---
title: "REACH MAp"
author: "Sebastian Di Geronimo"
date: 2025-10-13
format: html
editor: source
---

# 1.0 ---- Summary of Document ----



# 2.0 ---- Setup ----


## 2.1 Load Libraries

```{r setup, include=FALSE}
if (!nzchar(system.file(package = "librarian"))) 
  install.packages("librarian")

librarian::shelf(
  quiet = TRUE,
  librarian, conflicted, ggplot2, tibble, tidyr, readr, purrr, dplyr, stringr,
  forcats, lubridate, glue, fs, magrittr, here,
  
  # additional
  OpenStreetMap, leaflet,
  rerddap,
  sf
  
)

conflicts_prefer(
  dplyr::filter(), 
  dplyr::select()
  )
  

```

## 2.2 Load Dataset

```{r load-data}
dir_path <- 
  here() %>%
  rstudioapi::selectDirectory()
loc_dat <- 
  dir_path %>%
  dir_ls(regexp = "(?i)schedule") %>%
  str_subset("~", negate = TRUE) %>% 
  readxl::read_xlsx(.name_repair = janitor::make_clean_names, sheet = "Times_alt") %>%
  janitor::remove_empty("cols") %>%
  drop_na(latitude_decimal_degree, longitude_decimal_degree) %T>%
  print() %>%
  select(waypoint, description, 
         "lat" = latitude_decimal_degree, "long" = longitude_decimal_degree, 
         depth_m, departure_date_time_local
         ) %>%
  mutate(
    long = -long,
    date = as_date(departure_date_time_local),
    description = if_else(str_detect(description, "0"), "CTD/Net Trawl", description)
    ) %T>% 
  print()

# set location to save data and plots
dir_data_save <- here("data", "processed", "reach_map")
dir_plt_save  <- here("data", "plots", "reach_map")
```

## 2.3 Load Rice's Whale Distrbution Shapefile
Shapefile of Rice's Whale Distrbution from:
<https://www.fisheries.noaa.gov/resource/map/rices-whale-core-distribution-area-map-gis-data>
```{r load-data}
# shapefile path
whale_shp_path <- 
  here("data", "raw") %>%
  dir_ls(regexp = "Rices_whale") %>%
  dir_ls(regexp = "shp$")

# load whale distrbution shapefile
whale_shp <- st_read(whale_shp_path)
```


```{r}
# add boundaries for openstreemap
adj_deg <- 0.01 # degree widen
bounds <- 
  c(
    range(loc_dat$long) + c(-adj_deg, adj_deg),
    range(loc_dat$lat) + c(-adj_deg, adj_deg)
  ) %T>%
  print()
```


# 3.0 Plot using `leaflet`

Overall points

```{r leaflet}
leaflet::leaflet() %>%
  addTiles() %>%
  addMarkers(loc_dat$long, loc_dat$lat)

```

```{r}
source(here("scripts", "map_files_dwnlod.R"))

# add boundaries for openstreemap
adj_deg <- 1.5 # degree widen
bounds <- 
  c(
    range(loc_dat$long) + c(-adj_deg, adj_deg),
    range(loc_dat$lat) + c(-adj_deg, adj_deg - 0.8)
  ) %T>%
  print()

Sys.setenv(RERDDAP_DEFAULT_URL = "https://coastwatch.pfeg.noaa.gov/erddap/")

world_download(
  path_land = NULL,
  path_topo = here("data", "map_shp", "reach"),
  extent = bounds,
  etopo_version = "ETOPO_2022_v1_15s"
)
Sys.unsetenv("RERDDAP_DEFAULT_URL")
debugonce(world_download)

bathy <- 
  here("data", "map_shp", "reach") %>%
  dir_ls()  %>%
  terra::rast() %>%
  as.data.frame(xy = TRUE)

```

```{r}
long_lat_lag <- 
  loc_dat %>%
  mutate(
    lon_lag = dplyr::lead(long, default = -82.58745),
    lat_lag = dplyr::lead(lat, default = 27.67623),
    ) %>%
  mutate(
    .by = waypoint,
    te = row_number(),
    t2 = n(),
    waypoint = if_else(row_number() > 1, "", waypoint)
  ) %T>% 
  print()
```

# 4.0 Plt using `OpenStreeMap`

Inspired from: <https://ajsmit.github.io/Intro_R_Official/mapping-google.html>

```{r mangrove-stations}
# add boundaries for openstreemap
adj_deg <- c(0.3, 1.25) # degree widen
bounds <- 
  c(
    range(loc_dat$long) + c(-adj_deg[1], adj_deg[2]),
    range(loc_dat$lat) + c(-adj_deg[1], adj_deg[2] - 0.8)
  ) %T>%
  print()

bounds[1] <- -88.5
bounds[2] <- -82
bounds[3] <- 26.5

# extract openstreemap tiles
osm_map <-
  openmap(
    bounds[c(4, 1)], # upperleft
    bounds[c(3, 2)], # loweright
    zoom = 9,
    # type = "esri-topo", 
    type = "esri-imagery", 
    mergeTiles = TRUE
  ) %>%
  openproj()

# OpenStreetMap::autoplot.OpenStreetMap(osm_map)
  
loc_map <-
  # plot openstreemap
  OpenStreetMap::autoplot.OpenStreetMap(osm_map) +
  metR::geom_contour2(
    data = bathy,
    aes(
      x = x,
      y = y,
      z = -z
    ),
    col = "grey70",
    breaks = c(3000, 2000, 1000, 500, 100, 50, 25)
  ) +
  geom_sf(
    data        = whale_shp,
    color       = "grey40",
    fill        = prismatic::clr_lighten("grey40"),
    linewidth   = 0.75,
    alpha       = 0.5,
    linetype    = "dashed",
    inherit.aes = FALSE
  )

loc_map_pts <-
  loc_map +

  # add arrows for cruise track
  ggarchery::geom_arrowsegment(
    data = long_lat_lag,
    aes(
      x     = long,
      xend  = lon_lag,
      y     = lat,
      yend  = lat_lag,
      color = fct_reorder(format(date, "%B %d"), date)
    ),
    # color = "green",
    arrow_positions = 0.5,
    arrows = arrow(length = unit(0.1, "inches")),
    na.rm = TRUE,
    key_glyph = draw_key_point
    # show.legend = FALSE
  ) +

  # add station points
  geom_point(
    data = loc_dat,
    aes(
      x = long, 
      y = lat, 
      fill = fct_reorder(format(date, "%B %d"), date), 
      shape = description
      ),
    size = 3,
    # shape = 21
    # show.legend = FALSE
  ) +

  # add station labels
  ggrepel::geom_text_repel(
    data = distinct(long_lat_lag, waypoint, lat, long),
    aes(x = long, y = lat, label = waypoint),
    max.overlaps       = 15,
    min.segment.length = 0.0,
    size               = 3.5,
    # uncomment for bold letters
    fontface      = "bold",
    color         = "white",
    bg.color      = "black",
    bg.r          = 0.15,
    segment.color = "black",
    # direction     = "x"
  ) +
  labs(
    title = "REACH-002 (October 27 - November 5)",
    x     = NULL, # "Longitude (°)",
    y     = NULL, # "Latitude (°)",
    color = NULL,
    shape = NULL
  ) +
  scale_shape_manual(values = c(21:25)) +
  coord_sf(expand = FALSE, xlim = bounds[1:2], ylim = bounds[3:4]) +
  guides(
    color = guide_legend(
      keywidth     = 0.05,
      keyheight    = 0.05,
      default.unit = "inch"
    ),
    shape = guide_legend(position = "bottom"),
    fill = "none"
  ) +
  theme_bw() +
  theme(
    legend.position        = "inside",
    legend.position.inside = c(0.91, 0.8),
    legend.text            = element_text(size = 7)
  )

loc_map_pts
```



# 5.0 Save Plots using `camcorder`

After running, will need to redisplay plots for it to

```{r camcorder}
shelf(camcorder)
camcorder::gg_record(
  dir    = here::here("data", "cam_test", "reach_map"),
  device = "png",
  dpi    = 600,
  units  = "mm",
  bg     = "white"
)

shell.exec(here::here("data", "cam_test", "reach_map"))

# uncomment if need to resize
# camcorder::gg_resize_film(width = 90, height = 90 * 0.5625,  dpi = 600, units = "mm")

```

## 5.1 When done saving plots

```{r stop-camcorder}
camcorder::gg_stop_recording()
```


```{r}
bathy2 <- 
  here("data", "map_shp", "reach") %>%
  dir_ls()  %>%
  terra::rast()

# 1. Extract contours using base R
clines <- contourLines(
  x = sort(unique(bathy$x)),
  y = sort(unique(bathy$y)),
  z = rev(matrix(-bathy$z, nrow = length(unique(bathy$x)), byrow = FALSE)),
  levels = c(25, 50, 100, 500, 1000, 2000, 3000)
)
  rev(matrix(-bathy$z, nrow = length(unique(bathy$x)), byrow = FALSE)[1:10, 1:10])
clines %>%
  str()
# 2. Find the longest segment for each level
contour_df <- do.call(rbind, lapply(clines, function(cl) {
  data.frame(
    level = cl$level, 
    x = cl$x, 
    y = cl$y, 
    length = length(cl$x)
  )
}))
unique(contour_df$level)
longest <- 
  contour_df %>%
  # group_by(level) %>%
  summarise(
    .by = level,
    # Use the segment with the most points (or your preferred metric)
    idx = which.max(length)
  )
distinct(contour_df, length)
# 3. Label only these segments
# (Alternatively, you may need to join or filter your original 'bathy' or contour data for plotting)

# 4. In your ggplot: use metR geom_label_contour/data for those only (omitting many details since
# extra wrangling is needed).
label_points <- contour_df %>%
  group_by(level) %>%
  summarise(
    x_label = mean(x),  # or x[middle point]
    y_label = mean(y)
  )

ggplot() +
  geom_path(
    data = contour_df,  # all your contour segments for all levels
    aes(x = x, y = y, group = interaction(level, length), color = factor(level))
  ) +
  geom_text(
    data = label_points,
    aes(x = x_label, y = y_label, label = level),
    color = "black", fontface = "bold", size = 4
  )
```



