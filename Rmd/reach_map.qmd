---
title: "REACH MAp"
author: "Sebastian Di Geronimo"
date: 2025-10-13
format: html
editor: source
---

# 1.0 ---- Summary of Document ----



# 2.0 ---- Setup ----


## 2.1 Load Libraries

```{r setup, include=FALSE}
if (!nzchar(system.file(package = "librarian"))) 
  install.packages("librarian")

librarian::shelf(
  quiet = TRUE,
  librarian, conflicted, ggplot2, tibble, tidyr, readr, purrr, dplyr, stringr,
  forcats, lubridate, glue, fs, magrittr, here,
  
  # additional
  OpenStreetMap, leaflet,
  rerddap,
  sf
  
)

conflicts_prefer(
  dplyr::filter(), 
  dplyr::select()
  )
  

```

## 2.2 Contour Label Function

```{r func-contour-label}
contour_labels <- function(
    contour, 
    z_name = "z",
    n_per_level = 2, 
    breaks      = c(3000, 2000, 1000, 500, 100, 50, 25), 
    quantiles   = 0.2,
    slice_type  = c("max", "random")
    ) {
  
  library(isoband)
  
  z <- matrix(-contour[[z_name]], nrow = length(unique(contour$y)), byrow = TRUE)
  
  # list of contours breaks with id, x, y as sub-list
  iso <- isolines(
    x = sort(unique(contour$x)),
    y = sort(unique(contour$y)),
    z = z[length(unique(contour$y)):1, ],
    levels = breaks
  )
  # combine iso list of for each contour break keeping contour level
  contours_df <-
    imap(
      iso,
      \(.x, .y) {
        as_tibble(.x) %>%
          mutate(.before = 1, level = .y)
      }
    ) %>%
    list_c()
  # calculate the distances between segments of same ID
  contours_df <-
    contours_df %>%
    arrange(level, id, row_number()) %>%
    mutate(
      .by       = c(level, id),
      dx        = dplyr::lag(x, default = first(x)),
      dy        = dplyr::lag(y, default = first(y)),
      seg_len   = geosphere::distHaversine(cbind(x, y), cbind(dx, dy)) / 1000,
      seg_cum   = cumsum(seg_len),
      seg_total = max(seg_cum)
    )

  label_pts <-
    contours_df %>%
    # drop segments less than x% by level
    filter(seg_total >= quantile(seg_total, quantiles, na.rm = TRUE), .by = level) %>%
    summarise(
      .by = c(level, id),
      # choose mid-point along this segment
      target = max(seg_cum) / 2,
      seg_total = max(seg_cum),
      idx = which.min(abs(seg_cum - target)),
      x = x[idx],
      y = y[idx],
    )
  
  # at most n_per_level
  if (slice_type == "max") {
    label_pts <- 
      label_pts %>%
      slice_max(order_by = seg_total, n = n_per_level, with_ties = FALSE, by = level)
  } else if (slice_type == "min") {
    label_pts <- 
      label_pts %>%
      slice_min(order_by = seg_total, n = n_per_level, with_ties = FALSE, by = level)
  } else if (slice_type == "random") {
    label_pts <- 
      label_pts %>%
        slice_sample(n = 1, by = level)
  } else {
    warning(
      paste0(
        "Pick slice_type:\n", 
        "- max = select top lengths\n", 
        "- random = select 2 random\n",
        "Currently, not reducing labels by n_per_level"
        )
      )
  }

  return(label_pts)
  # ---- end of function contour_labels ---- #
}

```


## 2.3 Load Dataset

```{r load-data}
reach_cruise_id <- "REACH-004 (March 1 - 9)"

if (!exists("dir_path")) {
  dir_path <-
    here() %>%
    rstudioapi::selectDirectory() %>%
    dir_ls(regexp = "(?i)schedule") %>%
    str_subset("~", negate = TRUE)
}

if (length(dir_path) > 1) {
  dir_path <-
    dir_path[
      str_detect(
        dir_path, 
        select.list(basename(dir_path), title = "Select correct spreadsheet:")
        )
      ]
}

sheet_names <- 
  dir_path  %>% 
  readxl::excel_sheets() %T>% 
  print()

loc_dat <- 
  dir_path %>% 
  readxl::read_xlsx(.name_repair = janitor::make_clean_names, sheet = sheet_names[2]) %>%
  janitor::remove_empty("cols") %>%
  drop_na(latitude_decimal_degree, longitude_decimal_degree) %T>%
  print() %>%
  select(
    waypoint, description, 
    "lat"  = dec_lat, 
    "long" = dec_lon,
    depth_m, departure_date_time_local
    ) %>%
  mutate(
    date = as_date(departure_date_time_local),
    description = if_else(str_detect(description, "0"), "CTD/Net Trawl", description)
    ) %T>% 
  print()

# set location to save data and plots
dir_plt_save  <- here("data", "plots", "reach_map")
```

## 2.3 Load Rice's Whale Distrbution Shapefile
Shapefile of Rice's Whale Distrbution from:
<https://www.fisheries.noaa.gov/resource/map/rices-whale-core-distribution-area-map-gis-data>
```{r load-data}
# shapefile path
whale_shp_path <- 
  here("data", "raw") %>%
  dir_ls(regexp = "Rices_whale") %>%
  dir_ls(regexp = "shp$")

# load whale distrbution shapefile
whale_shp <- st_read(whale_shp_path)
```


```{r}
# add boundaries for openstreemap
adj_deg <- 0.01 # degree widen
bounds <- 
  c(
    range(loc_dat$long) + c(-adj_deg, adj_deg),
    range(loc_dat$lat) + c(-adj_deg, adj_deg)
  ) %T>%
  print()
```


# 3.0 Plot using `leaflet`

Overall points

```{r leaflet}
leaflet::leaflet() %>%
  addTiles() %>%
  addMarkers(
    loc_dat$long, 
    loc_dat$lat, 
    label = loc_dat$waypoint, 
    labelOptions = labelOptions(noHide = TRUE)
    )

```

## 3.1 Download Bathymetry

```{r}
source(here("scripts", "map_files_dwnlod.R"))

# add boundaries for openstreemap
adj_deg <- 1.5 # degree widen
bounds <- 
  c(
    range(loc_dat$long) + c(-adj_deg, adj_deg),
    range(loc_dat$lat) + c(-adj_deg, adj_deg - 0.8)
  ) %T>%
  print()

Sys.setenv(RERDDAP_DEFAULT_URL = "https://coastwatch.pfeg.noaa.gov/erddap/")

world_download(
  path_land = NULL,
  path_topo = here("data", "map_shp", "reach"),
  extent = bounds,
  etopo_version = "ETOPO_2022_v1_15s"
)
Sys.unsetenv("RERDDAP_DEFAULT_URL")
debugonce(world_download)

bathy <- 
  here("data", "map_shp", "reach") %>%
  dir_ls()  %>%
  terra::rast() %>%
  as.data.frame(xy = TRUE)

contour_breaks <- c(3000, 2000, 1000, 500, 100, 50, 25)

bathy_contour_label <- contour_labels(bathy, n_per_level = 1, breaks = contour_breaks, slice_type = "max")

```

```{r}
long_lat_lag <- 
  loc_dat %>%
  mutate(
    lon_lag = dplyr::lead(long, default = first(long)),
    lat_lag = dplyr::lead(lat, default = first(lat)),
    ) %>%
  mutate(
    .by = waypoint,
    te = row_number(),
    t2 = n(),
    waypoint = if_else(row_number() > 1, "", waypoint)
  ) %T>% 
  print()
```


# 4.0 Plt using `OpenStreeMap`

Inspired from: <https://ajsmit.github.io/Intro_R_Official/mapping-google.html>

```{r mangrove-stations}
# add boundaries for openstreemap
adj_deg <- c(0.3, 1.25) # degree widen
bounds <- 
  c(
    range(loc_dat$long) + c(-adj_deg[1], adj_deg[2]),
    range(loc_dat$lat) + c(-adj_deg[1], adj_deg[2] - 0.8)
  ) %T>%
  print()

bounds[1] <- -88.5
bounds[2] <- -82
bounds[3] <- 26.5

# extract openstreemap tiles
osm_map <-
  openmap(
    bounds[c(4, 1)], # upperleft
    bounds[c(3, 2)], # loweright
    zoom = 8,
    # type = "esri-topo", 
    type = "esri-physical", 
    mergeTiles = TRUE
  ) %>%
  openproj()

# OpenStreetMap::autoplot.OpenStreetMap(osm_map)
  
(loc_map <-
  # plot openstreemap
  OpenStreetMap::autoplot.OpenStreetMap(osm_map) +
    
  # contour lines
  metR::geom_contour2(
    data = bathy,
    aes(
      x = x,
      y = y,
      z = -z
    ),
    col = "grey90",
    breaks = contour_breaks
  ) +
  # contour labels
  shadowtext::geom_shadowtext(
    data = bathy_contour_label,
    aes(x, y, label = level),
    size = rel(3),
    colour = "gray30",
    bg.colour = "white",
    alpha = 0.7
  ) +
    
  # whale habitat polygon
  geom_sf(
    data        = whale_shp,
    color       = "grey40",
    fill        = prismatic::clr_lighten("grey40"),
    linewidth   = 0.75,
    alpha       = 0.5,
    linetype    = "dashed",
    inherit.aes = FALSE
  ) + 
  labs(
    title = reach_cruise_id,
    # title = NULL,
    x     = NULL, # "Longitude (°)",
    y     = NULL, # "Latitude (°)",
    color = NULL,
    shape = NULL
  ) +
  coord_sf(expand = FALSE, xlim = bounds[1:2], ylim = bounds[3:4])
  )
```


```{r plt-stations}
shp_label_dict <- 
  c(
  "CTD"      = 24,
  "Arrive"   = 21,
  "Waypoint" = 21,
  "Surface Buoy/CTD"     = 25,
  "CTD/Bongo and Tucker" = 22,
  "CTD/Bongo and Tucker/Subsurface" = 22,
  "Subsurface Mooring Test Deployment" = 22
)

# catch if new description exist in schedule
if (any(!loc_dat$description %in% names(shp_label_dict))) {
  missing_lbl <- 
  unique(loc_dat$description[which(!loc_dat$description %in% names(shp_label_dict))])
  stop(
    paste(
      "Missing shape label! Please add missing description and shape number.\n",
      "Missing label:", missing_lbl
          ))
}

loc_map_pts <-
  loc_map +

  # # add arrows for cruise track
  # ggarchery::geom_arrowsegment(
  #   data = long_lat_lag,
  #   aes(
  #     x     = long,
  #     xend  = lon_lag,
  #     y     = lat,
  #     yend  = lat_lag,
  #     color = fct_reorder(format(date, "%B %d"), date)
  #   ),
  #   # color = "green",
  #   arrow_positions = 0.5,
  #   arrows = arrow(length = unit(0.1, "inches")),
  #   na.rm = TRUE,
  #   key_glyph = draw_key_point
  #   # show.legend = FALSE
  # ) +

  # add station points
  geom_point(
    data = loc_dat,
    aes(
      x = long, 
      y = lat, 
      fill = fct_reorder(format(date, "%B %d"), date), 
      shape = description
      ),
    size = 3,
    # shape = 21
    # show.legend = FALSE
  ) +

  # add station labels
  ggrepel::geom_text_repel(
    data = distinct(long_lat_lag, waypoint, lat, long),
    aes(x = long, y = lat, label = waypoint),
    max.overlaps       = 15,
    min.segment.length = 0.0,
    size               = 3.5,
    # uncomment for bold letters
    fontface      = "bold",
    color         = "white",
    bg.color      = "black",
    bg.r          = 0.15,
    segment.color = "black",
  ) +

  scale_shape_manual(values = shp_label_dict) +
  guides(
    color = guide_legend(
      keywidth     = 0.05,
      keyheight    = 0.05,
      default.unit = "inch"
    ),
    shape = guide_legend(position = "bottom", nrow = 1),
    fill = "none"
  ) +
  theme_bw() +
  theme(
    legend.position        = "inside",
    legend.position.inside = c(0.91, 0.8),
    legend.text            = element_text(size = 7)
  )
```


```{r show-stations}
loc_map_pts 
```

# 5.0 Save Plots using `camcorder`

After running, will need to redisplay plots for it to

```{r camcorder}
shelf(camcorder)
camcorder::gg_record(
  dir    = here::here("data", "cam_test", "reach_map"),
  device = "png",
  dpi    = 600,
  width = 11,
  height = 8.5,
  units  = "in",
  bg     = "white"
)

# currently needs this to save
# will need to have plot in plot window before can save
camcorder::record_polaroid() 

shell.exec(here::here("data", "cam_test", "reach_map"))

# uncomment if need to resize
# camcorder::gg_resize_film(width = 90, height = 90 * 0.5625,  dpi = 600, units = "mm")

```

## 5.1 When done saving plots

```{r stop-camcorder}
camcorder::gg_stop_recording()
```






